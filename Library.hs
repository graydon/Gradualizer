module Library where

import TypeSystem
import ToLambdaProlog

librarySig :: [(String, String)]
librarySig = [
  ("none", ""),
  ("stlc", "sig stlc.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% context app 1[], 2[1].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_add", "sig stlc_add.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\tadd\t\tterm -> term -> term.\ntype\tzero\t\tterm.\ntype\tsucc\t\tterm -> term.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo zero :- constructor, int.\n% operatorInfo succ :- constructor, int.\n% operatorInfo add :- deconstructor, int, 1, covariant, 1.\n% context app 1[], 2[1].\n% context add 1[], 2[1].\n% context succ 1[].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_exc", "sig stlc_exc.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\ntype\terror\t\t\tterm -> o.\n\ntype\t\texcType\t\t\ttyp.\ntype\t\traise\t\t\ttyp -> term -> term.\ntype\t\ttry\t\t\t\tterm -> term -> term.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% context app 1[], 2[1].\n% context try 1[].\n% context raise 1[].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_fix", "sig stlc_fix.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tfix\t\tterm -> term.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo fix :- derived, arrow, 1, contravariant, 1.\n% context app 1[], 2[1].\n% context fix 1[].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_if", "sig stlc_if.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tbool\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tif\t\tterm -> term -> term -> term.\ntype\t\ttt\tterm.\ntype\t\tff\tterm.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo if :- deconstructor, bool, 1, covariant, 1.\n% context app 1[], 2[1].\n% context if 1[], 2[1], 3[1,2].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_inference", "sig stlc_inference.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tabsInf\t\t(term -> term) -> term.\n\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo absInf :- constructor, arrow.\n% context app 1[], 2[1].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_let", "sig stlc_let.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tlet\t\tterm -> (term -> term) -> term.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo let :- derived.\n% context app 1[], 2[1].\n% context let 1[].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_letrec", "sig stlc_letrec.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tfix\t\tterm -> term.\ntype\t\tlet\t\tterm -> (term -> term) -> term.\ntype\t\tletrec\t\ttyp -> (term -> term) -> (term -> term) -> term.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo fix :- derived, arrow, 1, contravariant, 1.\n% operatorInfo let :- derived.\n% operatorInfo letrec :- derived.\n% context app 1[], 2[1].\n% context fix 1[].\n% context let 1[].\n% context letrec 1[].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_lists", "sig stlc_lists.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\tbool\t\t\ttyp.\ntype\tlist\t\t\ttyp -> typ.\n\ntype\ttt\t\tterm.\ntype\tff\t\tterm.\ntype\temptyList\ttyp -> term.\ntype\tisnil\t\ttyp -> term -> term. \ntype\tcons\t\ttyp -> term -> term -> term. \ntype\thead \t\ttyp -> term -> term. \ntype\ttail \t\ttyp -> term -> term. \n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo emptyList :- constructor, list.\n% operatorInfo cons :- constructor, list.\n% operatorInfo isnil :- deconstructor, list, 1, covariant.\n% operatorInfo head :- deconstructor, list, 1, covariant.\n% operatorInfo tail :- deconstructor, list, 1, covariant.\n% context app 1[], 2[1].\n% context isnil 2[].\n% context head 2[].\n% context tail 2[].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_pairs", "sig stlc_pairs.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\tpairType\t\ttyp -> typ -> typ.\ntype\tpair\t\t\tterm -> term -> term.\ntype\tfst\t\t\t\tterm -> term.\ntype\tsnd\t\t\t\tterm -> term.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo pair :- constructor, pairType.\n% operatorInfo fst :- deconstructor, arrow, 1, covariant.\n% operatorInfo snd :- deconstructor, arrow, 1, covariant.\n% context app 1[], 2[1].\n% context pair 1[], 2[1].\n% context fst 1[].\n% context snd 1[].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  
  ("stlc_ref", "sig stlc_ref.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> heap -> term -> heap -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\trefType\t\ttyp -> typ.\ntype\t\tunitType\ttyp.\n\ntype\t\tunit\t\tterm.\ntype\t\tref\t\t\tterm -> term.\ntype\t\tderef\t\tterm -> term.\ntype\t\tassign\t\tterm -> term -> term.\n\nkind\theap\t\t\ttype.\nkind\taddress\t\t\ttype.\ntype\tloc\t\t\taddress -> term.\ntype\temptyHeap\t\t\theap.\ntype\tentry\t\t\taddress -> term -> heap -> heap.\ntype\tlookup\t\t\taddress -> heap -> term -> o.\ntype\tfresh\t\t\taddress -> heap -> o.\ntype\ttypeOfRuntype\t\t\taddress -> typ -> o.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo ref :- constructor, refType.\n% operatorInfo deref :- deconstructor, refType, 1, covariant.\n% operatorInfo assign :- deconstructor, refType, 1, contravariant, 1.\n% context app 1[], 2[1].\n% context ref 1[].\n% context deref 1[].\n% context assign 1[], 2[1].\n% mode typeOf inp -> out.\n% mode step inp -> inp -> out -> out.\n% mode typeOfRuntype inp -> out.\n% mode lookup inp -> inp -> out -> out.\n% mode fresh inp -> inp.\n"),

  ("stlc_subtype", "sig stlc_subtype.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\ntype\tsubtype\t\t\ttyp -> typ -> o.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% context app 1[], 2[1].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n% mode subtype inp -> inp.\n"),
  ("stlc_sum", "sig stlc_sum.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype \tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\t\tplus\t\ttyp -> typ -> typ.\n\ntype\t\tcase \t\tterm -> (term -> term) -> (term -> term) -> term.\ntype\t\tinl\t\t\ttyp -> term -> term.\ntype\t\tinr\t\t\ttyp -> term -> term.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo case :- deconstructor, plus, 1, covariant.\n% operatorInfo inl :- constructor, plus.\n% operatorInfo inr :- constructor, plus.\n% context app 1[], 2[1].\n% context plus 1[], 2[1].\n% context case 1[].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_tuples", "sig stlc_tuples.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype\ttupleType\t\ttyp -> typ -> typ -> typ -> typ.\ntype\ttuple\t\t\tterm -> term -> term -> term -> term.\ntype\tselect1\t\t\t\tterm -> term.\ntype\tselect2\t\t\t\tterm -> term.\ntype\tselect3\t\t\t\tterm -> term.\ntype\tselect4\t\t\t\tterm -> term.\n\nkind\theap\t\t\ttype.\nkind\taddress\t\t\ttype.\ntype\tloc\t\t\taddress -> term.\ntype\temptyHeap\t\t\theap.\ntype\tentry\t\t\taddress -> term -> heap -> heap.\ntype\tlookup\t\t\taddress -> heap -> term -> o.\ntype\tfresh\t\t\taddress -> heap -> o.\ntype\ttypeOfRuntype\t\t\taddress -> typ -> o.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant, 1.\n% operatorInfo tuple :- constructor, tupleType.\n% operatorInfo select1 :- deconstructor, tupleType, 1, covariant.\n% operatorInfo select2 :- deconstructor, tupleType, 1, covariant.\n% operatorInfo select3 :- deconstructor, tupleType, 1, covariant.\n% operatorInfo select4 :- deconstructor, tupleType, 1, covariant.\n% context app 1[], 2[1].\n% context tuple 1[],2[1],3[1,2],4[1,2,3].\n% context select1 1[].\n% context select2 1[].\n% context select3 1[].\n% context select4 1[].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n"),
  ("stlc_unit", "sig stlc_unit.\n\nkind\tterm\t\t\ttype.\nkind\ttyp\t\t\t\ttype.\n\ntype\tint\t\t\ttyp.\ntype\tarrow\t\ttyp -> typ -> typ.\n\ntype    app\t\t\tterm -> term -> term.\ntype    abs\t\t\ttyp -> (term -> term) -> term.\n\ntype\ttypeOf\t\t\tterm -> typ -> o. \n\ntype\tstep\t\t\tterm -> term -> o.\ntype\tvalue\t\t\tterm -> o.\n\ntype \tunitType \ttyp.\ntype\tunit\t\tterm.\n\n% operatorInfo abs :- constructor, arrow.\n% operatorInfo app :- deconstructor, arrow, 1, contravariant.\n% operatorInfo unit :- constructor, unitType.\n% context app 1[], 2[1].\n% mode typeOf inp -> out.\n% mode step inp -> out.\n")
           ]

libraryRules :: [(String, String)]
libraryRules = [
  ("none", ""),
  ("stlc", "module stlc.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\nvalue (abs T E).\nstep (app (abs T E1) E2) (E1 E2).\n"),
  ("stlc_add", "module stlc_add.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (add E1 E2) (int) :- typeOf E1 (int), typeOf E2 (int).\ntypeOf (zero) (int).\ntypeOf (succ E) (int) :- typeOf E (int).\n\nvalue (abs T E).\nvalue (succ E) :- value E.\nvalue zero.\nstep (app (abs T E1) E2) (E1 E2).\n"),
  ("stlc_exc", "module stlc_exc.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (raise T E) T :- typeOf E (excType).\ntypeOf (try E1 E2) T :- typeOf E1 T, typeOf E2 (arrow (excType) T).\n\nvalue (abs T E).\nerror (raise T E).\nstep (try V E)  V :- value V.\nstep (try (raise T V) E)  (app E V) :- value V.\n"),
   ("stlc_fix", "module stlc_fix.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (fix E) T :- typeOf E (arrow T T).\n\nvalue (abs T E).\nstep (fix V) (app V (fix V)) :- value V.\n"),
  ("stlc_if", "module stlc_if.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (if E1 E2 E3) T :- typeOf E1 (bool), typeOf E2 T, typeOf E3 T.\ntypeOf (tt) (bool).\ntypeOf (ff) (bool).\n\nvalue (abs T E).\nvalue (tt).\nvalue (ff).\nstep (if (tt) E1 E2) E1.\nstep (if (ff) E1 E2) E2.\n"),
  ("stlc_inference", "module stlc_inference.\n\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (absInf E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\n\nvalue (absInf E).\nstep (app (absInf E1) E2) (E1 E2).\n"),
  ("stlc_let", "module stlc_let.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (let E1 E2) T2 :- typeOf E1 T1, (pi x\\ (typeOf x T1 => typeOf (E2 x) T2)).\n\nvalue (abs T E).\nstep (let V E) (E V) :- value V.\n"),
  ("stlc_letrec", "module stlc_letrec.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (fix E) T :- typeOf E (arrow T T).\ntypeOf (let E1 E2) T2 :- typeOf E1 T1, (pi x\\ (typeOf x T1 => typeOf (E2 x) T2)).\ntypeOf (letrec T1 E1 E2) T2 :- (pi x\\ (typeOf x T1 => typeOf (E1 x) T1)), (pi x\\ (typeOf x T1 => typeOf (E2 x) T2)).\n\nvalue (abs T E).\nstep (fix V) (app V (fix V)) :- value V.\nstep (let V E) (E V) :- value V.\nstep (letrec T E1 E2) (let (fix (abs T E1)) E2).\n"),
  ("stlc_lists", "module stlc_lists.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (tt) (bool).\ntypeOf (ff) (bool).\ntypeOf (emptyList T) (list T).\ntypeOf (isnil T E) (bool) :- typeOf E (list T).\ntypeOf (cons T E1 E2) (list T) :- typeOf E1 T, typeOf E2 (list T).\ntypeOf (head T E) T :- typeOf E (list T).\ntypeOf (tail T E) T :- typeOf E (list T).\n\nvalue (abs T E).\nvalue (tt).\nvalue (ff).\nvalue (emptyList T).\nvalue (cons T V1 V2) :- value V1, value V2.\nstep (isnil T (emptyList T)) (tt).\nstep (isnil T (cons T E1 E2)) (ff).\nstep (head T (cons T E1 E2)) E1.\nstep (tail T (cons T E1 E2)) E2.\n"),
  ("stlc_pairs", "module stlc_pairs.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (pair E1 E2) (pairType T1 T2) :- typeOf E1 T1, typeOf E2 T2.\ntypeOf (fst E) T1 :- typeOf E (pairType T1 T2).\ntypeOf (snd E) T2 :- typeOf E (pairType T1 T2).\n\nvalue (abs T E).\nvalue (pair V1 V2) :- value V1, value V2.\nstep (fst (pair E1 E2)) E1.\nstep (snd (pair E1 E2)) E2.\n"),
  ("stlc_ref", "module stlc_ref.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (unit) (unitType).\ntypeOf (ref E) (refType T) :- typeOf E T.\ntypeOf (deref E) T :- typeOf E (refType T).\ntypeOf (assign E1 E2) (unitType) :- typeOf E1 (refType T), typeOf E2 T.\n\nstep (app (abs T E1) E2) M (E1 E2) M.\n\nvalue (abs T E).\nvalue (unit).\nvalue (ref V) :- value V.\n\ntypeOf (loc L) (refType T) :- typeOfRuntype L T.\nstep (ref V) M (loc L) (entry L V M) :- fresh L M, value V.\n\nstep (assign (loc L) V) M (unit) (entry L V M) :- value V.\n\nstep (deref (loc L)) M V M :- lookup L M V.\n"),
  ("stlc_subtype", "module stlc_subtype.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T3, subtype T1 T3.\nvalue (abs T E).\nstep (app (abs T E1) E2) (E1 E2).\n"),
  ("stlc_sum", "module stlc_sum.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (case E E1 E2) T :- typeOf E (plus T1 T2), (pi x\\ (typeOf x T1 => typeOf (E1 x) T)), (pi x\\ (typeOf x T2 => typeOf (E2 x) T)).\ntypeOf (inl T2 E) (plus T1 T2) :- typeOf E T1.\ntypeOf (inr T1 E) (plus T1 T2) :- typeOf E T2.\n\nvalue (abs T E).\nvalue (inl T V) :- value V.\nvalue (inr T V) :- value V.\nstep (case (inl T V) E1 E2) (E1 V) :- value V.\nstep (case (inr T V) E1 E2) (E2 V) :- value V.\n"),
  ("stlc_tuples", "module stlc_tuples.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (tuple E1 E2 E3 E4) (tupleType T1 T2 T3 T4) :- typeOf E1 T1, typeOf E2 T2, typeOf E3 T3, typeOf E4 T4.\ntypeOf (select1 E) T1 :- typeOf E (tupleType T1 T2 T3 T4).\ntypeOf (select2 E) T2 :- typeOf E (tupleType T1 T2 T3 T4).\ntypeOf (select3 E) T3 :- typeOf E (tupleType T1 T2 T3 T4).\ntypeOf (select4 E) T4 :- typeOf E (tupleType T1 T2 T3 T4).\n\nvalue (abs T E).\nvalue (tuple V1 V2 V3 V4) :- value V1, value V2, value V3, value V4.\nstep (select1 (tuple E1 E2 E3 E4)) E1.\nstep (select2 (tuple E1 E2 E3 E4)) E2.\nstep (select3 (tuple E1 E2 E3 E4)) E3.\nstep (select4 (tuple E1 E2 E3 E4)) E4.\n"),
  ("stlc_unit", "module stlc_unit.\n\ntypeOf (abs T1 E) (arrow T1 T2) :- (pi x\\ (typeOf x T1 => typeOf (E x) T2)).\ntypeOf (app E1 E2) T2 :- typeOf E1 (arrow T1 T2), typeOf E2 T1.\ntypeOf (unit) (unitType).\n\nvalue (abs T E).\nvalue (unit).\n")
           ]

preLibrary :: [String]
preLibrary =
           [
           "none",
           "stlc",
           "stlc_add",
           "stlc_exc",
           "stlc_fix",
           "stlc_if",
           "stlc_inference",
           "stlc_let",
           "stlc_letrec",
           "stlc_lists",
           "stlc_pairs",
           "stlc_ref",
           "stlc_subtype",
           "stlc_sum",
           "stlc_tuples",
           "stlc_unit"
           ]

getSelectionSig :: Int -> Maybe String
getSelectionSig n = lookup (preLibrary !! n) librarySig

getSelectionRules :: Int -> Maybe String
getSelectionRules n = lookup (preLibrary !! n) libraryRules

preLibraryWithTitles  :: [(String, String)]
preLibraryWithTitles =
           [
           ("none", ""),
           ("stlc", "Simply Typed Lambda Calculus (STLC)"),
           ("stlc_add", "STLC with Integers and Addition"),
           ("stlc_exc", "STLC with Exceptions"),
           ("stlc_fix", "STLC with Recursion (Fix operator)"), 
           ("stlc_if", "STLC with Booleans and If-statement"),
           ("stlc_inference", "STLC in Type Inference style"), 
           ("stlc_let", "STLC with Let bindings"),
           ("stlc_letrec", "STLC with Letrec bindings"), 
           ("stlc_lists", "STLC with Lists"), 
           ("stlc_pairs", "STLC with Pairs"), 
           ("stlc_ref", "STLC with References"), 
           ("stlc_subtype", "STLC with Subtyping"),
           ("stlc_sum", "STLC with Sum Types"), 
           ("stlc_tuples", "STLC with the Tuples"), 
           ("stlc_unit", "STLC with the Unit type")
           ]

